var documenterSearchIndex = {"docs":
[{"location":"man/mcmc_setup/#Definition-of-the-MCMC-sampler-1","page":"MCMC Setup","title":"Definition of the MCMC sampler","text":"","category":"section"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"To define the MCMC sampler there are two objects that need to be defined. First, we must specify a range of possible transition kernels that the MCMC sampler can use (these transition kernels can change and adapt as the MCMC sampler progresses if certain settings are turned on). These will be stored in the object MCMCSetup. We then have to specify the schedule i.e. what steps need to be taken by the MCMC sampler at each of its step.","category":"page"},{"location":"man/mcmc_setup/#MCMC-Setup-1","page":"MCMC Setup","title":"MCMC Setup","text":"","category":"section"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"As in the previous section, we define transition steps for the problem of inference for diffusion processes. We will need two types of updates: imputations and parameter updates. Suppose that we don't use any blocking, to see how to modify the code below to include blocking see this page. Then imputation can be defined via:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"precond_Crank_Nicolson = ...\nODE_solver = ... # possible choices Ralston3, RK4, Tsit5, Vern7\nimpute_step = Imputation(NoBlocking(), precond_Crank_Nicolson, ODE_solver)","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"Imputation","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"To define parameter updates more parameters need to be defined:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"pu1 = ParamUpdate(MetropolisHastingsUpdt(), # the type of parameter update\n                  5,                        # which coordinate is updated\n                  θ_init,                   # needed just for the dimension of the parameter\n                  UniformRandomWalk(0.5, true), # transition kernel\n                  ImproperPosPrior(),       # prior\n                  UpdtAuxiliary(            # auxiliary information\n                      Vern7(),              # ODE solver\n                      true))                # whether the update prompts for re-computing H,Hnu,c\npu2 = ...","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"Then the setup can be defined as:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"mcmc_setup = MCMCSetup(impute_step, pu1, pu2)","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"There are currently two different ways of updating parameters:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"ConjugateUpdt\nMetropolisHastingsUpdt","category":"page"},{"location":"man/mcmc_setup/#BridgeSDEInference.ConjugateUpdt","page":"MCMC Setup","title":"BridgeSDEInference.ConjugateUpdt","text":"ConjugateUpdt <: ParamUpdateType\n\nType acting as a flag for update from full conditional (conjugate to a prior)\n\n\n\n\n\n","category":"type"},{"location":"man/mcmc_setup/#BridgeSDEInference.MetropolisHastingsUpdt","page":"MCMC Setup","title":"BridgeSDEInference.MetropolisHastingsUpdt","text":"MetropolisHastingsUpdt <: ParamUpdateType\n\nFlag for performing update according to Metropolis Hastings step\n\n\n\n\n\n","category":"type"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"And two generic transition kernels:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"UniformRandomWalk\nGaussianRandomWalk","category":"page"},{"location":"man/mcmc_setup/#MCMC-schedule-1","page":"MCMC Setup","title":"MCMC schedule","text":"","category":"section"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"It is now necessary to tell the mcmc sampler what to do at each iteration. To this end let's define the MCMCSchedule","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"MCMCSchedule","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"An example of how to define it is given here:","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"MCMCSchedule(111, [[1,2], [1,3]],\n              (save=5, verbose=10, warm_up=7,\n                readjust=(x->x%20==0), fuse=(x->false)))","category":"page"},{"location":"man/mcmc_setup/#","page":"MCMC Setup","title":"MCMC Setup","text":"It specifies the total number of MCMC steps to be 111, and the array [[1,2], [1,3]] makes the sampler alternate between performing imputation and parameter update pu1 on each odd step and imputation and parameter update pu2 on each even step. It saves the imputed path on every 5th iteration, prints out useful progress message to the console every 10th step, ignores parameter update steps for the first 7 iterations readjusts the proposals once in every 20th step (see this page for more information on adaptive schemes). It also never fuses transition kernels (see this page for more information about fusion).","category":"page"},{"location":"man/diffusion_setup/#Defining-the-observational-scheme-1","page":"Diffusion Setup","title":"Defining the observational scheme","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"To run the MCMC sampler we need to pass a setup object that defines the statistical model. In this section we will show how to define a diffusion model using a pre-defined DiffusionSetup. Nonetheless, be aware that the logic of the MCMC sampler is independent from the model specification, so it is possible to use the mcmc routines from this package routine to run it on other statistical models. For more information about these types of extensions see Generic MCMC.","category":"page"},{"location":"man/diffusion_setup/#Defining-the-processes-1","page":"Diffusion Setup","title":"Defining the processes","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"To define the DiffusionSetup we need to decide on the Target diffusion, an Auxiliary diffusion and the observation scheme. For instance, suppose that there are three observations:","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"obs = [...]\nobs_times = [1.0, 2.0, 3.0]","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"Then we define the target diffusion globally and the auxiliary diffusion separately on each interval","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"P_target = TargetDiffusion(parameters)\nP_auxiliary = [AuxiliaryDiffusion(parameters, o, t) for (o,t) in zip(obs, obs_times)]","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"To define the setup for partially observed diffusion it is enough to write:","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"model_setup = DiffusionSetup(P_target, P_auxiliary, PartObs()) # for first passage times use FPT()","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"DiffusionSetup","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.DiffusionSetup","page":"Diffusion Setup","title":"BridgeSDEInference.DiffusionSetup","text":"MCMCSetup\n\nGroups together all objects that need to be passed to mcmc function from mcmc.jl.\n\n\n\n\n\n","category":"type"},{"location":"man/diffusion_setup/#Observations-1","page":"Diffusion Setup","title":"Observations","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"To set the observations, apart from passing the observations and observation times it is necessary to pass the observational operators and as well as covariance of the noise. Additionally, one can pass additional information about the first passage time scheme.","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"L = ...\nΣ = ...\nset_observations!(model_setup, [L for _ in obs], [Σ for _ in obs], obs, obs_time)","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"set_observations!","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.set_observations!","page":"Diffusion Setup","title":"BridgeSDEInference.set_observations!","text":"set_observations!(setup::DiffusionSetup, Ls, Σs, obs, obs_times,\n                  fpt=fill(nothing, length(obs)-1))\n\nStore observations to setup. The observations follow the scheme V=LX+η, where V are the observations in obs, observed at times given in obs_times, L are the observation operators given in Ls, X is the unobserved, underlying diffusion and η is a Gaussian noise with mean 0 and covariance Σ with the last stored in Σs. fpt provides additional information in case the nature of observations has to do with first-passage times\n\n\n\n\n\n","category":"function"},{"location":"man/diffusion_setup/#Imputation-grid-1","page":"Diffusion Setup","title":"Imputation grid","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"There are two objects that define the imputation grid. The time step dt and the time transformation that transforms a regular time-grid with equidistantly distributed imputation points. The second defaults to a usual transformation employed in papers on the guided proposals. [TO DO add also space-time transformation from the original paper for the bridges]. It is enough to call","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"dt = ...\nset_imputation_grid!(model_setup, dt)","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"set_imputation_grid!","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.set_imputation_grid!","page":"Diffusion Setup","title":"BridgeSDEInference.set_imputation_grid!","text":"set_imputation_grid!(setup::DiffusionSetup, dt,\n                     time_transf=(t₀,T) -> ((x) ->  t₀ + (x-t₀) * (2-(x-t₀)/(T-t₀))))\n\nDefine the imputation grid in setup. dt defines the granulatrity of the imputation grid and time_transf defines a time transformation to use for transforming equidistant grid.\n\n\n\n\n\n","category":"function"},{"location":"man/diffusion_setup/#Prior-over-the-starting-point-1","page":"Diffusion Setup","title":"Prior over the starting point","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"There are two types of priors for the starting point, either a delta hit at some specified value, corresponding to a known starting point and a Gaussian prior","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"KnownStartingPt\nGsnStartingPt","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.KnownStartingPt","page":"Diffusion Setup","title":"BridgeSDEInference.KnownStartingPt","text":"KnownStartingPt{T} <: StartingPtPrior\n\nIndicates that the starting point is known and stores its value in y\n\n\n\n\n\n","category":"type"},{"location":"man/diffusion_setup/#BridgeSDEInference.GsnStartingPt","page":"Diffusion Setup","title":"BridgeSDEInference.GsnStartingPt","text":"GsnStartingPt{T,S} <: StartingPtPrior\n\nIndicates that the starting point is equipped with a Gaussian prior with mean μ and covariance matrix Σ. It also stores the most recently sampled white noise z used to compute the starting point and a precision matrix Λ:=Σ⁻¹. μ₀ and Σ₀ are the mean and covariance of the white noise\n\nGsnStartingPt(μ::T, Σ::S)\n\nBase constructor. It initialises the mean μ and covariance Σ parameters and Λ is set according to Λ:=Σ⁻¹\n\n\n\n\n\n","category":"type"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"For instance, to set a known starting point it is enough to call:","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"set_x0_prior!(model_setup, KnownStartingPt(x0))","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"set_x0_prior!","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.set_x0_prior!","page":"Diffusion Setup","title":"BridgeSDEInference.set_x0_prior!","text":"set_priors!(setup::DiffusionSetup, priors, x0_prior, x0_guess=nothing)\n\nStore the priors over parameters (in priors) and over the starting point (in x0_prior) into the object setup.\n\n\n\n\n\n","category":"function"},{"location":"man/diffusion_setup/#Auxiliary-parameters-1","page":"Diffusion Setup","title":"Auxiliary parameters","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"There are two auxiliary parameters that can be set by the user. The first one is a thinning factor for saving the paths that are sampled by the MCMC sampler. The second specifies an adaptation scheme for tuning Guided proposals [TODO change the latter].","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"set_auxiliary!","category":"page"},{"location":"man/diffusion_setup/#Initialisation-of-internal-containers-1","page":"Diffusion Setup","title":"Initialisation of internal containers","text":"","category":"section"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"Once all the setting functions above have been run (with the only exception set_auxiliary! being optional), i.e.","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"setup = DiffusionSetup(...)\nset_observations!(setup, ...)\nset_imputation_grid(setup, ...)\nset_x0_prior!(setup, ...)","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"then the following function should be run","category":"page"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"initialise!","category":"page"},{"location":"man/diffusion_setup/#BridgeSDEInference.initialise!","page":"Diffusion Setup","title":"BridgeSDEInference.initialise!","text":"initialise(::Type{K}, setup::DiffusionSetup; verbose=false)\n\nInitialise the internal containers of setup. Check if all the necessary data has been passed to setup\n\n\n\n\n\n","category":"function"},{"location":"man/diffusion_setup/#","page":"Diffusion Setup","title":"Diffusion Setup","text":"Once run, the model setup is complete.","category":"page"},{"location":"examples/sine/#Sine-diffusion-1","page":"Sine diffusion","title":"Sine diffusion","text":"","category":"section"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"d X_t = a + bsin(c + X_t)dt + sigma dW_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"extras/first_passage_times/#FPT_header-1","page":"First passage times","title":"First passage times","text":"","category":"section"},{"location":"extras/first_passage_times/#","page":"First passage times","title":"First passage times","text":"TODO","category":"page"},{"location":"man/run/#Running-the-MCMC-sampler-1","page":"Running the sampler","title":"Running the MCMC sampler","text":"","category":"section"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"Running the MCMC sampler is very simple, it is enough to call","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"mcmc","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"passing the initialised MCMCSetup, MCMCSchedule and DiffusionSetup objects, as follows:","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"out = mcmc(mcmc_setup, schedule, model_setup)","category":"page"},{"location":"man/query/#Querying-the-inference-results-1","page":"Querying the results","title":"Querying the inference results","text":"","category":"section"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"The output of running the mcmc function is a Workspace object.","category":"page"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"Workspace","category":"page"},{"location":"man/query/#BridgeSDEInference.Workspace","page":"Querying the results","title":"BridgeSDEInference.Workspace","text":"Workspace{ObsScheme,S,TX,TW,R,ST}\n\nThe main container of the mcmc function from mcmc.jl in which most data pertinent to sampling is stored\n\n\n\n\n\n","category":"type"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"Querying the output can be done simply by calling the members of an instance of Workspace that is returned by the mcmc sampler. The task of writing suitable functions for this is left mainly to the user, we provide some generic plotting functions that can be used for testing here (not part of the package).","category":"page"},{"location":"examples/fitzhugh_nagumo/#Parametrisations-of-FitzHugh-Nagumo-model-1","page":"FitzHugh-Nagumo model","title":"Parametrisations of FitzHugh-Nagumo model","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"There are 5 distinct parametrisations of the FitzHugh-Nagumo model implemented in this package. They are explained in turn below","category":"page"},{"location":"examples/fitzhugh_nagumo/#:regular-1","page":"FitzHugh-Nagumo model","title":":regular","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This is the most commonly encountered parametrisation of the FitzHugh-Nagumo model. The target, two dimensional process (Y,X) solves the following stochastic differential equation:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dt\ndX_t = left( gamma Y_t - X_t + beta right )dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The proposal is taken to be a guided proposal with auxiliary law (Image: equation) induced by the linear diffusion obtained by linearising FitzHugh-Nagumo diffusion at an end-point:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd widetildeY_t = frac1epsilonleft( left( 1-3y_T^2 right )widetildeY_t - widetildeX_t + s + 2y_T^3 right)dt\ndwidetildeX_t = left( gamma widetildeY_t - widetildeX_t + beta right)dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:simpleAlter-1","page":"FitzHugh-Nagumo model","title":":simpleAlter","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The target stochastic differential equations is re-parametrised in such a way that the first coordinate is given by the integrated second coordinate:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = dotY_t dt\nddotY_t = frac1epsilonleft( (1-gamma)Y_t -Y_t^3 -epsilon dotY_t + s - beta + left( 1-3Y_t^2 right)dotY_t right)dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The auxiliary law (Image: equation) is now induced by a pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd I_t = B_tdt\ndB_t = fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:complexAlter-1","page":"FitzHugh-Nagumo model","title":":complexAlter","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The stochastic differential equation solved by the target process is the same as in :simpleAlter. However, the auxliary law (Image: equation) is induced by a two-dimensional diffusion, where the second coordinate is a linear diffusion obtained from linearising (Image: equation) at an end-point and the first coordinate is an integrated second coordinate. If only the first coordinate is observed the proposal takes a form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 right )widetildeY_t +left( 1-epsilon-3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta right )right dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"On the other hand, if both coordinates are observed, the proposal is given by:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 - 6y_Tdoty_T right )widetildeY_t +left( 1-epsilon -3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta + 6y_T^2doty_T right )right dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:simpleConjug-1","page":"FitzHugh-Nagumo model","title":":simpleConjug","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to :simpleAlter, the only difference being that an additional step is taken of redefining the parameters:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"sleftarrow fracsepsilonquad betaleftarrowfracbetaepsilonquad sigmaleftarrowfracsigmaepsilonquad gammaleftarrowfracgammaepsilonquad epsilonleftarrowfrac1epsilon","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This results in the target law of the form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = dotY_t dt\nddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"And the proposal law:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd I_t = B_tdt\ndB_t = sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:complexConjug-1","page":"FitzHugh-Nagumo model","title":":complexConjug","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to :complexAlter, the only difference being that an additional step is taken of redefining the parameters (just as it was done in :simpleConjug above). Consequently the target law is as given above, in the section on :simpleConjug parametrisation, whereas proposal law is given by:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = left left epsilonleft(1-3y_T^2 - 6y_Tdoty_T right )-gamma right widetildeY_t +left epsilonleft( 1-3y_T^2 right)-1 right widetildeX_t + leftepsilonleft(2y_T^3+ 6y_T^2doty_T right ) +s-beta rightright dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/prokaryote/#Prokaryotic-autoregulatory-gene-network-1","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"","category":"section"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"dX_t = b(X_t)dt + sigma(X_t) dW_t","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"where","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"b(x)=left(beginmatrix\nc_3 x^4 - c_7 x^1\nc_4 x^1 + 2f(x) - c_8 x^3\ng(x)-f(x)\ng(x)\nendmatrixright)","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"with","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"beginalign*\nf(x)=c_6 x^3-05c_5x^2(x^2-1)\ng(x)=c_2(K-x^4)-c_1 x^3x^4\nendalign*","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"and","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"sigma(x)","category":"page"},{"location":"adaptations/adaptive_proposals/#adaptive_header-1","page":"Adaptive proposals","title":"Adaptive proposals","text":"","category":"section"},{"location":"adaptations/adaptive_proposals/#","page":"Adaptive proposals","title":"Adaptive proposals","text":"TODO","category":"page"},{"location":"man/model_definition/#Definition-of-a-diffusion-process-1","page":"Defining a diffusion","title":"Definition of a diffusion process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"To define a diffusion model suitable for inference with BridgeSDEInference.jl one must define two processes:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"the target diffusion\nand the auxiliary diffusion","category":"page"},{"location":"man/model_definition/#Imports-1","page":"Defining a diffusion","title":"Imports","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The diffusion definitions will extend some of the functionality of the existing functions from Bridge.jl, so the following imports are necessary:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"using Bridge\nimport Bridge: b, σ, B, β, a, constdiff","category":"page"},{"location":"man/model_definition/#Definition-of-the-target-process-1","page":"Defining a diffusion","title":"Definition of the target process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The target process needs to be a struct inheriting from ContinuousTimeProcess{ℝ{d,T}} (where d is a dimension of the diffusion) with the first type parameter {T} defining the data-type of the parameters. The members of the struct must define the diffusion process and are usually limited to a list of parameters. An example of a valid definition of a 10 dimensional diffusion with two parameters alpha and beta would be","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"struct TargetDiffusion{T} <: ContinuousTimeProcess{ℝ{10,T}}\n    α::T\n    β::T\n    TargetDiffusion(α::T, β::T) where T = new{T}(α, β)\nend","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"Then, one must specify the dynamics of the diffusion by specifying the behaviour of the drift and volatility functions b and σ (defined in Bridge.jl) for TargetDiffusion:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"b(t, x, P::TargetDiffusion) = foo(t, x, P.α, P.β)\nσ(t, x, P::TargetDiffusion) = bar(t, x, P.α, P.β)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where foo and bar are some user-defined functions. Finally, three auxiliary functions must be defined:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"constdiff(::TargetDiffusion) = false","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"indicating whether σ(t, x, P::TargetDiffusion) is independent from the values of x and t,","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"clone(P::TargetDiffusion, θ) = TargetDiffusion(θ...)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"which returns a new copy of the process with new set of parameters, and finally","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"params(P::TargetDiffusion) = [P.α, P.β]","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"which returns an array with all parameter values. Optionally, functions nonhypo, hypo_a_inv, num_non_hypo and phi can be defined to make it possible to perform conjugate updates of the parameters (see ... for more details on conjugate updates [TODO add])","category":"page"},{"location":"man/model_definition/#Definition-of-the-auxiliary-process-1","page":"Defining a diffusion","title":"Definition of the auxiliary process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The auxiliary diffusion, similarly, needs to be a struct inheriting from ContinuousTimeProcess{ℝ{d,T}} with the first type parameter {T} defining the data-type of the parameters. It is often necessary for the auxiliary diffusion to have to have access to the information regarding the starting and ending time of the interval on which it is defined. Additionally, the starting and end-point of the target process are also sometimes used (if available). An example of a definition of the auxiliary diffusion is:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"struct AuxiliaryDiffusion{R,S1,S2}\n    α::R\n    β::R\n    t::Float64    # starting time of the interval\n    u::S1         # starting position of the target process\n    T::Float64    # end-time of the interval\n    v::S2         # final position of the target process\n    AuxiliaryDiffusion(α::R, β::R, t, u::S1, T, v::S2) = new{R,S1,S2}(α, β, t, u, T, v)\nend","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"It is now necessary to specify the dynamics of the process. Unlike in the case of the Target, specifying the volatility coefficient is not necessary and it is sufficient to only provide a diffusion coefficient (a:=σσ'). The package supports only linear diffusions as auxiliary processes and thus function b should be defined as:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"b(t, x, P::AuxiliaryDiffusion) = B(t, P) * x + β(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where B and β need to be overwritten as follows:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"B(t, P::AuxiliaryDiffusion) = foo2(t, P)\nβ(t, P::AuxiliaryDiffusion) = foo3(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where the user-defined functions foo2 and foo3 should return a d by d matrix and a length-d vector respectively. One needs to define the diffusion coefficient","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"a(t, P::AuxiliaryDiffusion) = bar2(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"As previously, the clone constructor, params and also a convenience function returning the names of the paramters:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"clone(P::AuxiliaryDiffusion, θ) = AuxiliaryDiffusion(θ..., P.t, P.u, P.T, P.v)\nparams(P::AuxiliaryDiffusion) = (P.α, P.β)\nparam_names(P::AuxiliaryDiffusion) = (:α, :β)","category":"page"},{"location":"examples/lorenz63/#Lorenz-'63-system-1","page":"Lorenz63 system","title":"Lorenz '63 system","text":"","category":"section"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign*\nd X_t = a (Y_t - X_t) dt + sigma_x dW^(1)_t \ndY_t = X_t (b - Z_t) - Y_tdt + sigma_y dW^(2)_t\ndZ_t = X_t Y_t - c Z_tdt + dW^(3)_t\nendalign*","category":"page"},{"location":"extras/generic_mcmc/#Generic-MCMC-1","page":"Generic MCMC","title":"Generic MCMC","text":"","category":"section"},{"location":"extras/blocking/#blocking_header-1","page":"Blocking","title":"Blocking","text":"","category":"section"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"NOTE THESE DESCRIPTIONS ARE DEPRECATED AND WILL CHANGE","category":"page"},{"location":"extras/blocking/#Blocking-1","page":"Blocking","title":"Blocking","text":"","category":"section"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"Currently two choices of blocking are available:","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"Either no blocking at all, which is the default behaviour of set_blocking!","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"NoBlocking","category":"page"},{"location":"extras/blocking/#BridgeSDEInference.NoBlocking","page":"Blocking","title":"BridgeSDEInference.NoBlocking","text":"struct NoBlocking <: BlockingSchedule end\n\nRegular updates with no blocking\n\n\n\n\n\n","category":"type"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"Or blocking using the chequerboard updating scheme.","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"ChequeredBlocking","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"For chequerboard updating scheme, at each observation a knot can be (but does not have to be) placed. IMPORTANT: The knot indexing starts at the first non-starting point observation. Suppose we have, say, 20 observations (excluding the starting point). Let's put a knot on every other observation, ending up with knots on observations with indices: [2,4,6,8,10,12,14,16,18,20]. Chequerboard updating scheme splits these knots into two, disjoint, interlaced subsets, i.e. [2,6,10,14,18] and [4,8,12,16,20]. This also splits the path into two interlaced sets of blocks: [1–2,3–6,7–10,11–14,15–18,19–20], [1–4,5–8,9–12,13–16,17–20] (where interval indexing starts with interval 1, whose end-points are the starting point and the first non-starting point observation). The path is updated in blocks. First, blocks [1–2,3–6,7–10,11–14,15–18,19–20] are updated conditionally on full and exact observations indexed with [2,6,10,14,18], as well as all the remaining, partial observations (indexed by [1,2,3,...,20]). Then, the other set of blocks is updated in the same manner. This is then repeated. To define the blocking behaviour, only the following needs to be written:","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"blocking = ChequeredBlocking()\nblocking_params = (collect(2:20)[1:2:end], 10^(-10), SimpleChangePt(100))","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"The first defines the blocking updating scheme (in the future there might be a larger choice). The second line places the knots on [2,4,6,8,10,12,14,16,18,20]. Splitting into appropriate subsets is done internally. 10^(-10) is an artificial noise parameter that needs to be added for the numerical purposes. Ideally we want this to be as small as possible, however the algorithm may have problems with dealing with very small values. The last arguments aims to remedy this. SimpleChangePt(100) has two functions. One, it is a flag to the mcmc sampler that two sets of ODE solvers need to be employed: for the segment directly adjacent to a knot from the left ODE solvers for M⁺, L, μ are employed and H, Hν and c are computed as a by-product. On the remaining part of blocks, the ODE solvers for H, Hν and c are used directly. The second function of SimpleChangePt() is to indicate the point at which a change needs to be made between these two solvers (which for the example above is set to 100). The reason for this functionality is that solvers for M⁺, L, μ are more tolerant to very small values of the artificial noise.","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"To define an MCMC sampler with no blocking nothing needs to be done (it's a default). Alternatively, one can call","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"set_blocking!()","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"It resets the blocking to none. To pass the blocking scheme defined above one could call","category":"page"},{"location":"extras/blocking/#","page":"Blocking","title":"Blocking","text":"set_blocking!(setup, blocking, blocking_params)","category":"page"},{"location":"man/overview/#Overview-of-the-workflow-1","page":"Workflow","title":"Overview of the workflow","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"A typical workflow consists of five stages (or six if the data also needs to be generated).","category":"page"},{"location":"man/overview/#Stage-1-(a)-1","page":"Workflow","title":"Stage 1 (a)","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Define a diffusion model. Some examples are included in the folder src/examples. See Definition of a diffusion process for a list of functions that need (and optionally might) be implemented to fully define a diffusion process.","category":"page"},{"location":"man/overview/#Stage-1-(b)-1","page":"Workflow","title":"Stage 1 (b)","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Generate the data. Naturally in applied work the data is given and this step is skipped. However, for tests it is often convenient to work with simulated data. Data generation is not an internal part of the package; however some generic methods that allow for simulation of observations can be found in folders (...). See also Data Generation.","category":"page"},{"location":"man/overview/#Stage-2-1","page":"Workflow","title":"Stage 2","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Define the model setup. This includes the type of a model together with all the necessary parametrisations is needed to fully spedcfor  of the","category":"page"},{"location":"man/overview/#Stage-3-1","page":"Workflow","title":"Stage 3","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Define the MCMC chain. This amounts to specifying the range of possible transition steps (together with their transition kernels and priors) and the MCMC schedule which lists the order of steps and actions that need to be undertaken by the MCMC sampler.","category":"page"},{"location":"man/overview/#Stage-4-1","page":"Workflow","title":"Stage 4","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Run the mcmc function. This is a one-liner:","category":"page"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"out = mcmc(mcmc_setup, schedule, model_setup)","category":"page"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"where mcmc_setup, schedule, model_setup are defined in the stages 2 & 3 above.","category":"page"},{"location":"man/overview/#Stage-5-1","page":"Workflow","title":"Stage 5","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Query the results. This step is mostly left to a user. There are a couple of generic plotting functions defined in (...), which are not part of the package. The output are two objects: Workspace and MCMCWorkspace, please see Querying the inference results for an overview of their members and some auxiliary functions that can be used to visualise the results.","category":"page"},{"location":"vis/visualisation/#Visualisations-1","page":"Visualisation tools","title":"Visualisations","text":"","category":"section"},{"location":"vis/visualisation/#","page":"Visualisation tools","title":"Visualisation tools","text":"Interactive visualisations of the FitzHugh-Nagumo system using Makie library are given here","category":"page"},{"location":"examples/jansen_rit/#Jansen-Rit-model-1","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"","category":"section"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"beginequation*\n    beginaligned\n        d X_t = dot X_t d t  \n        d Y_t = dot Y_t d t  \n        d Z_t = dot Z_t d t \n        d dot X_t =   leftA a left(mu_x(t) + mboxSigm(Y_t - Z_t)right) - 2a dot X_t - a^2 X_tright d t + sigma_x d W^(1)_t\n        d dot Y_t =  leftA a left(mu_y(t) + C_2mboxSigm(C_1 X_t)right) - 2a dot Y_t - a^2 Y_tright d t + sigma_y d W^(2)_t\n        d dot Z_t =  leftB b left(mu_z(t) + C_4mboxSigm(C_3 X_t)right) - 2b dot Z_t - b^2 Z_tright d t + sigma_z d W^(3)_t\n    endaligned\nendequation*","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"with initial condition","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(X_0Y_0Z_0 dot X_0 dot Y_0 dot Z_0)=(x_0y_0z_0 dot x_0 dot y_0 dot z_0) in R^6","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"where","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mboxSigm(x) = fracnu_max1 + e^r(v_0 - x)","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"C_1 = C quad C_2 = 08C quad C_4 = C_3 = 025C","category":"page"},{"location":"adaptations/fusion/#fusion_header-1","page":"Fusion","title":"Fusion of transition kernels","text":"","category":"section"},{"location":"adaptations/fusion/#","page":"Fusion","title":"Fusion","text":"not implemented yet","category":"page"},{"location":"examples/lorenz96/#Lorenz-'96-system-1","page":"Lorenz96 system","title":"Lorenz '96 system","text":"","category":"section"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"dX_t = b_theta(X_t)dt + Sigma dW_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where X and W are d-dimensional, Sigma is a d by d diagonal matrix and b is given by:","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"b^i_theta(x)= (x^i+1-x^i-2)x^i-1-x^i+theta","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where iin1dotsd is a cycling  index.","category":"page"},{"location":"#BridgeSDEInference.jl-1","page":"Home","title":"BridgeSDEInference.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MCMC sampler for inference for diffusion processes with the use of Guided Proposals using the package Bridge.jl. Currently under development.","category":"page"},{"location":"#Problem-statements-1","page":"Home","title":"Problem statements","text":"","category":"section"},{"location":"#Partially-observed-diffusion-1","page":"Home","title":"Partially observed diffusion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider a stochastic process X, a solution to the stochastic differential equation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqmainSDE\nd X_t = b_theta(tX_t)dt + sigma_theta(tX_t)dW_tquad tin0Tquad X_0=x_0\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where b_thetaR^dto R^d is the drift function, sigma_thetaR^dto R^dtimes d is the volatility coefficient and W is a d-dimensional standard Brownian motion. We refer to X as a diffusion. thetain R^p is some unknown parameter. Suppose that a linearly transformed X, perturbed by Gaussian noise is observed at some collection of time points, i.e. that","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqpartObsData\nD=V_t_i i=1dots N\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"is observed for some t_i i=1dots N, where","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqpartialObservations\nV_t_i=L_i X_t_i + xi_i\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"with L_iin R^d_itimes d and independent xi_isim Gsn(0Sigma_i), (i=1dotsd). Suppose further that theta is equipped with some prior distribution pi(theta). The aim is to estimate the posterior distribution over theta, given the observation set D:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqposterior\npi(thetaD)propto pi(theta)pi(Dtheta)\nendequation","category":"page"},{"location":"#First-passage-time-observations-1","page":"Home","title":"First passage time observations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider a stochastic differential equation (\\ref{eq:mainSDE}) and suppose that the first coordinate of the drift term b_theta^1(tx)R^dto R is linear in x, whereas the first row of the volatility coefficient is identically equal to a zero vector sigma_theta^11d=0. Suppose further that instead of partial observation scheme as in (\\ref{eq:partObsData}), the process X is observed at a collection of stopping times:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"D=tau^star_i i=1dotsN","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where tau^star_i's are defined by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginalign*\ntau_star0=0\ntau^star_i+1=inftgeq tau_stari X_t^1geq l^star_i+1quad i=0dots\ntau_stari=inftgeq tau^star_i X_t^1leq l_stariquad i=1dots\nendalign*","category":"page"},{"location":"#","page":"Home","title":"Home","text":"for some known constants l^star_i, l_stari, i=1dots. Note that tau^star_i's are the first passage times of the first coordinate process to some thresholds l^star_i, whereas tau_stari are the (latent) renewal times. The aim is to find a posterior (\\ref{eq:posterior}) from such first passage time data.","category":"page"},{"location":"#Mixed-effects-models-1","page":"Home","title":"Mixed-effects models","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider M stochastic differential equations","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequation\nd X^(i)_t = b_thetaeta_i(tX^(i)_t)dt + sigma_thetaeta_i(tX^(i)_t)dW^(i)_tquad tin0Tquad X^(i)_0=x^(i)_0quad i=1dotsM\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where thetain R^p denotes the parameter that is shared among all of X^(i)'s, whereas eta_iin R^p_i, i=1dotsM are the parameters specific to a given X^(i). Suppose that the observations of the type (\\ref{eq:partObsData}) are given for each trajectory X^(i) (let's denote a joint set with D^star=cup_i=1^M D_i). The aim is to find the posterior:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pi(thetaeta_ii=1dots MD^star)propto pi(theta)prod_i=1^Mpi(eta_i)pi(D_ithetaeta_i)","category":"page"},{"location":"#Overview-of-the-solutions-in-BridgeSDEInference.jl-1","page":"Home","title":"Overview of the solutions in BridgeSDEInference.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The first two problems from Problem statements are addressed by the function","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mcmc","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The third problem (Mixed-effects models) is addressed by the function (TODO fix so that points to a function in repeated.jl)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mcmc","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Please see the Tutorial section to see how to appropriately initialise setup, run the mcmc function and query the results.","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"These are only the references which describe the algorithms implemented in this package. Note in particular that the list of references which treat the same problems as addressed by this package, but use methods which are not based on guided proposals is much, much longer. We refer to the bibliography sections of the papers listed below for references to other approaches.","category":"page"},{"location":"#Partial-observations-of-a-diffusion-1","page":"Home","title":"Partial observations of a diffusion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Guided proposals for diffusion bridges (no-noise setting):\nMoritz Schauer, Frank van der Meulen, Harry van Zanten. Guided proposals for simulating multi-dimensional diffusion bridges. Bernoulli, 23(4A), 2017, pp. 2917–2950. [Bernoulli], [arXiv].\nBayesian inference with guided proposals for diffusions observed exactly and discretely in time:\nFrank van der Meulen, Moritz Schauer. Bayesian estimation of discretely observed multi-dimensional diffusion processes using guided proposals. Electronic Journal of Statistics 11 (1), 2017. [EJoS], [arXiv].\nBayesian inference with guided proposals for diffusions observed with noise (according to (\\ref{eq:partialObservations})):\nFrank van der Meulen, Moritz Schauer. Bayesian estimation of incompletely observed diffusions. Stochastics 90 (5), 2018, pp. 641–662. [Stochastics], [arXiv].\nSimulation of hypo-elliptic diffusion bridges:\nJoris Bierkens, Frank van der Meulen, Moritz Schauer. Simulation of elliptic and hypo-elliptic conditional diffusions. arXiv, 2018. [arXiv].\nEfficient schemes for computing all the necessary term for a fully generic implementation of guided proposals:\nFrank van der Meulen, Moritz Schauer. Continuous-discrete smoothing of diffusions. arXiv, 2017. [arXiv].","category":"page"},{"location":"#First-passage-time-set_observations-1","page":"Home","title":"First passage time set_observations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"None published","category":"page"},{"location":"#Mixed-effect-models-1","page":"Home","title":"Mixed-effect models","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"None published","category":"page"},{"location":"man/generate_data/#Generation-of-data-1","page":"Data generation","title":"Generation of data","text":"","category":"section"},{"location":"man/generate_data/#","page":"Data generation","title":"Data generation","text":"There are three short scripts for generating data; they are available here. They illustrate how data can be generated in the setting of partially observed diffusion processes, first passage time observations as well as repeated observations (the last will soon be changed to mixed-effect models). In all three the main workhorse routine is simulateSegment, defined here (not part of the package, TODO maybe make it part of it). The FPT setting additionally uses findCrossings, defined in the same place.","category":"page"}]
}
