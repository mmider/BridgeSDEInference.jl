<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining a diffusion · BridgeSDEInference.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BridgeSDEInference.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../overview/">Workflow</a></li><li class="current"><a class="toctext" href>Defining a diffusion</a><ul class="internal"><li><a class="toctext" href="#Imports-1">Imports</a></li><li><a class="toctext" href="#Definition-of-the-target-process-1">Definition of the target process</a></li><li><a class="toctext" href="#Definition-of-the-auxiliary-process-1">Definition of the auxiliary process</a></li></ul></li><li><a class="toctext" href="../generate_data/">Data generation</a></li><li><a class="toctext" href="../diffusion_setup/">Diffusion Setup</a></li><li><a class="toctext" href="../mcmc_setup/">MCMC Setup</a></li><li><a class="toctext" href="../run/">Running the sampler</a></li><li><a class="toctext" href="../query/">Querying the results</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/fitzhugh_nagumo/">FitzHugh-Nagumo model</a></li><li><a class="toctext" href="../../examples/jansen_rit/">Jansen-Rit model</a></li><li><a class="toctext" href="../../examples/lorenz63/">Lorenz63 system</a></li><li><a class="toctext" href="../../examples/lorenz96/">Lorenz96 system</a></li><li><a class="toctext" href="../../examples/prokaryote/">Prokaryotic autoregulatory gene network</a></li><li><a class="toctext" href="../../examples/sine/">Sine diffusion</a></li></ul></li><li><a class="toctext" href="../../vis/visualisation/">Visualisation tools</a></li><li><span class="toctext">Extras</span><ul><li><a class="toctext" href="../../extras/generic_mcmc/">Generic MCMC</a></li><li><a class="toctext" href="../../extras/first_passage_times/">First passage times</a></li><li><a class="toctext" href="../../extras/blocking/">Blocking</a></li></ul></li><li><span class="toctext">Adaptations</span><ul><li><a class="toctext" href="../../adaptations/adaptive_proposals/">Adaptive proposals</a></li><li><a class="toctext" href="../../adaptations/fusion/">Fusion</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorial</li><li><a href>Defining a diffusion</a></li></ul><a class="edit-page" href="https://github.com/mmider/BridgeSDEInference.jl/blob/master/docs/src/man/model_definition.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Defining a diffusion</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Definition-of-a-diffusion-process-1" href="#Definition-of-a-diffusion-process-1">Definition of a diffusion process</a></h1><p>To define a diffusion model suitable for inference with <code>BridgeSDEInference.jl</code> one must define two processes:</p><ul><li>the <code>target</code> diffusion</li><li>and the <code>auxiliary</code> diffusion</li></ul><h2><a class="nav-anchor" id="Imports-1" href="#Imports-1">Imports</a></h2><p>The diffusion definitions will extend some of the functionality of the existing functions from <code>Bridge.jl</code>, so the following imports are necessary:</p><pre><code class="language-julia">using Bridge
import Bridge: b, σ, B, β, a, constdiff</code></pre><h2><a class="nav-anchor" id="Definition-of-the-target-process-1" href="#Definition-of-the-target-process-1">Definition of the target process</a></h2><p>The target process needs to be a struct inheriting from <code>ContinuousTimeProcess{ℝ{d,T}}</code> (where <code>d</code> is a dimension of the diffusion) with the first type parameter <code>{T}</code> defining the data-type of the parameters. The members of the struct must define the diffusion process and are usually limited to a list of parameters. An example of a valid definition of a <code>10</code> dimensional diffusion with two parameters <span>$\alpha$</span> and <span>$\beta$</span> would be</p><pre><code class="language-julia">struct TargetDiffusion{T} &lt;: ContinuousTimeProcess{ℝ{10,T}}
    α::T
    β::T
    TargetDiffusion(α::T, β::T) where T = new{T}(α, β)
end</code></pre><p>Then, one must specify the dynamics of the diffusion by specifying the behaviour of the drift and volatility functions <code>b</code> and <code>σ</code> (defined in <code>Bridge.jl</code>) for <code>TargetDiffusion</code>:</p><pre><code class="language-julia">b(t, x, P::TargetDiffusion) = foo(t, x, P.α, P.β)
σ(t, x, P::TargetDiffusion) = bar(t, x, P.α, P.β)</code></pre><p>where <code>foo</code> and <code>bar</code> are some user-defined functions. Finally, three auxiliary functions must be defined:</p><pre><code class="language-julia">constdiff(::TargetDiffusion) = false</code></pre><p>indicating whether <code>σ(t, x, P::TargetDiffusion)</code> is independent from the values of <code>x</code> and <code>t</code>,</p><pre><code class="language-julia">clone(P::TargetDiffusion, θ) = TargetDiffusion(θ...)</code></pre><p>which returns a new copy of the process with new set of parameters, and finally</p><pre><code class="language-julia">params(P::TargetDiffusion) = [P.α, P.β]</code></pre><p>which returns an array with all parameter values. Optionally, functions <code>nonhypo</code>, <code>hypo_a_inv</code>, <code>num_non_hypo</code> and <code>phi</code> can be defined to make it possible to perform conjugate updates of the parameters (see ... for more details on conjugate updates [TODO add])</p><h2><a class="nav-anchor" id="Definition-of-the-auxiliary-process-1" href="#Definition-of-the-auxiliary-process-1">Definition of the auxiliary process</a></h2><p>The auxiliary diffusion, similarly, needs to be a struct inheriting from <code>ContinuousTimeProcess{ℝ{d,T}}</code> with the first type parameter <code>{T}</code> defining the data-type of the parameters. It is often necessary for the auxiliary diffusion to have to have access to the information regarding the starting and ending time of the interval on which it is defined. Additionally, the starting and end-point of the target process are also sometimes used (if available). An example of a definition of the auxiliary diffusion is:</p><pre><code class="language-julia">struct AuxiliaryDiffusion{R,S1,S2}
    α::R
    β::R
    t::Float64    # starting time of the interval
    u::S1         # starting position of the target process
    T::Float64    # end-time of the interval
    v::S2         # final position of the target process
    AuxiliaryDiffusion(α::R, β::R, t, u::S1, T, v::S2) = new{R,S1,S2}(α, β, t, u, T, v)
end</code></pre><p>It is now necessary to specify the dynamics of the process. Unlike in the case of the <code>Target</code>, specifying the volatility coefficient is not necessary and it is sufficient to only provide a diffusion coefficient (<code>a:=σσ&#39;</code>). The package supports only linear diffusions as auxiliary processes and thus function <code>b</code> should be defined as:</p><pre><code class="language-julia">b(t, x, P::AuxiliaryDiffusion) = B(t, P) * x + β(t, P)</code></pre><p>where <code>B</code> and <code>β</code> need to be overwritten as follows:</p><pre><code class="language-julia">B(t, P::AuxiliaryDiffusion) = foo2(t, P)
β(t, P::AuxiliaryDiffusion) = foo3(t, P)</code></pre><p>where the user-defined functions <code>foo2</code> and <code>foo3</code> should return a <code>d</code> by <code>d</code> matrix and a length-<code>d</code> vector respectively. One needs to define the diffusion coefficient</p><pre><code class="language-julia">a(t, P::AuxiliaryDiffusion) = bar2(t, P)</code></pre><p>As previously, the <code>clone</code> constructor, <code>params</code> and also a convenience function returning the names of the paramters:</p><pre><code class="language-julia">clone(P::AuxiliaryDiffusion, θ) = AuxiliaryDiffusion(θ..., P.t, P.u, P.T, P.v)
params(P::AuxiliaryDiffusion) = (P.α, P.β)
param_names(P::AuxiliaryDiffusion) = (:α, :β)</code></pre><footer><hr/><a class="previous" href="../overview/"><span class="direction">Previous</span><span class="title">Workflow</span></a><a class="next" href="../generate_data/"><span class="direction">Next</span><span class="title">Data generation</span></a></footer></article></body></html>
